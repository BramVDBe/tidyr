% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rectangle.R
\name{hoist}
\alias{hoist}
\alias{unnest_longer}
\alias{unnest_wider}
\title{Rectangling tools: hosting & directional unnesting}
\usage{
hoist(.data, .col, ..., .remove = TRUE, .simplify = TRUE,
  .ptype = list())

unnest_longer(data, cols, values_to = "value", indices_to = "index",
  names_sep = NULL, names_repair = "check_unique")

unnest_wider(data, cols, names_sep = NULL, simplify = TRUE,
  names_repair = "check_unique", ptype = list())
}
\arguments{
\item{.data, data}{A data frame.}

\item{.col}{List-column to extract components from.}

\item{...}{Components of \code{.col} to turn into columns in the form
\code{col_name = "pluck_specification"}. You can pluck by name with a character
vector, by position with an integer vector, or with a combination of the
two with a list. See \code{\link[purrr:pluck]{purrr::pluck()}} for details.}

\item{.remove}{If \code{TRUE}, the default, will remove extracted components
from \code{.col}. This ensures that each value lives only in one place.}

\item{.simplify}{If \code{TRUE}, will attempt to simplify lists of length-1
vectors to an atomic vector}

\item{.ptype}{Optionally, a named list of prototypes declaring the desired
output type of each component.}

\item{cols}{Columns to unnest.}

\item{values_to}{Name of column to store vector values.}

\item{indices_to}{A string giving the name of a new column which will
contain the inner names of the values. If unnamed, \code{col} will instead
contain numeric indices.}

\item{names_sep}{If \code{NULL}, the default, the names of new columns will
come directly from the inner data frame.

If a string, the names of the new columns will be formed by pasting
together the outer column name with the inner names, separated by
\code{names_sep}.}

\item{names_repair}{Used to check that output data frame has valid
names. Must be one of the following options:
\itemize{
\item "minimal": No name repair or checks, beyond basic existence,
\item "unique": Make sure names are unique and not empty,
\item "check_unique": (the default), no name repair, but check they are unique,
\item "universal": Make the names unique and syntactic
\item a function: apply custom name repair.
\item a formula: a purrr-style anonymous function (see \code{\link[rlang:as_function]{rlang::as_function()}})
}

See \link[tibble:name-repair]{tibble::name-repair} for more details on these terms and the
strategies used to enforce them.}

\item{simplify}{If \code{TRUE}, will attempt to simplify lists of length-1
vectors to an atomic vector}

\item{ptype}{Optionally, supply a data frame prototype for the output \code{cols},
overriding the default that will be guessed from the combination of
individual values.}
}
\description{
\code{hoist()}, \code{unnest_longer()}, and \code{unnest_wider()} provide tools for
rectangling, collapsing deeply nested lists into regular columns.
\code{hoist()} allows you to selectively pull components of a list-column out
in to their own top-level columns, using the same syntax as \code{\link[purrr:pluck]{purrr::pluck()}}.
\code{unnest_wider()} turns each element of a list-column into a column, and
\code{unnest_longer()} turns each element of a list-column into a row.

Learn more in \code{vignette("rectangle")}.
}
\section{Unnest variants}{


The three \code{unnest()} functions differ in how they change the shape of the
output data frame:
\itemize{
\item \code{unnest_wider()} preserves the rows, but changes the columns.
\item \code{unnest_longer()} preserves the columns, but changes the rows
\item \code{unnest()} can change both rows and columns.
}

These principles guide their behaviour when they are called with a
non-primary data type. For example, if you \code{unnest_wider()} a list of data
frames, the number of rows must be preserved, so each column is turned into
a list column of length one. Or if you \code{unnest_longer()} a list of data
frame, the number of columns must be preserved so it creates a packed
column. I'm not sure how if these behaviours are useful in practice, but
they are theoretically pleasing.
}

\examples{
df <- tibble(
  character = c("Toothless", "Dory"),
  metadata = list(
    list(
      species = "dragon",
      color = "black",
      films = c(
        "How to Train Your Dragon",
        "How to Train Your Dragon 2",
        "How to Train Your Dragon: The Hidden World"
       )
    ),
    list(
      species = "clownfish",
      color = "blue",
      films = c("Finding Nemo", "Finding Dory")
    )
  )
)

df

# Turn all components of metadata into columns
df \%>\% unnest_wider(metadata)

# Extract only specified components
df \%>\% hoist(metadata,
  species = "species",
  first_film = list("films", 1L),
  third_film = list("films", 3L)
)

# unnest_longer() is useful when each component of the list should
# form a row
df <- tibble(
  x = 1:3,
  y = list(NULL, 1:3, 4:5)
)
df \%>\% unnest_longer(y)
# Automatically creates names if widening
df \%>\% unnest_wider(y)

# And similarly if the vectors are named
df <- tibble(
  x = 1:2,
  y = list(c(a = 1, b = 2), c(a = 10, b = 11, c = 12))
)
df \%>\% unnest_wider(y)
df \%>\% unnest_longer(y)

}
